/* Autogenerated with kurento-module-creator */

#include "FaceRecognitionOpenCVImpl.hpp"
#include "opencv2/opencv.hpp"
#include <KurentoException.hpp>
#include <opencv2/core/core.hpp>
#include <iostream>  
#include <fstream>
#include <sstream>
#include <dirent.h>
#include <vector>
#include <opencv2/imgproc/imgproc.hpp>
#include <opencv2/highgui/highgui.hpp>
#include <opencv2/contrib/contrib.hpp>

#define f_face_bracket_x 0.25
#define f_face_bracket_y 0.25

using namespace cv;
using namespace std;

namespace kurento
{
namespace module
{
namespace facerecognition
{

FaceRecognitionOpenCVImpl::FaceRecognitionOpenCVImpl ()
{

    path = "/home";
    opFilter = -1;
    newPerson = "default";

}

/*
 * This function will be called with each new frame. mat variable
 * contains the current frame. You should insert your image processing code
 * here. Any changes in mat, will be sent through the Media Pipeline.
 */

string pathDiretory = "";
int pic_num = 1;
int boolInit = 1;
vector<string> pastas;
Ptr<FaceRecognizer> modelXml;
CascadeClassifier face_cascade;

void loadDir(){

	DIR *dir;
	struct dirent *lsdir;
    	dir = opendir((pathDiretory+"/sample").c_str());
	pastas.clear();
    	while ( ( lsdir = readdir(dir) ) != NULL )
    	{
		if((lsdir->d_name)[0] != '.'){
			pastas.push_back(lsdir->d_name);
		}
    	}

    	closedir(dir);
}

void makepicture(cv::Mat &mat, string nameId)
{
	CascadeClassifier cascada;
	cascada.load(pathDiretory+"/haarcascade_frontalface_alt.xml");
	Mat frame;
	Mat myFace;
	int faceSize = 0;

	frame = mat;
	vector<Rect> faces;
	Mat frame_gray;
	cvtColor(frame, frame_gray, COLOR_BGR2GRAY);
	cascada.detectMultiScale(frame_gray, faces, 1.1, 4, CV_HAAR_DO_ROUGH_SEARCH, Size(70, 70), Size(1000, 1000));
	faceSize = faces.size();
	for (int i = 0; i < faceSize; i++)
	{
		rectangle(frame, faces[i], Scalar(255, 0, 0), 2, 8, 0);
	}
	if (faces.size() == 1)
	{
		Mat faceROI = frame_gray(faces[0]);
		resize(faceROI, myFace, Size(92, 112));
		putText(frame, to_string(pic_num), faces[0].tl(), 3, 1.2, CV_RGB(0,0,255), 2, 0);
		system(("mkdir "+pathDiretory+"/sample/"+nameId+"").c_str());
		string filename = pathDiretory+"/sample/"+nameId+"/"+to_string(pic_num)+".bmp";
		imwrite(filename, myFace);
		pic_num++;
	}

}

void initdata(cv::Mat &mat)
{
	loadDir();
	vector<Mat> img;
	vector<int> labels;
	int pastasSize = pastas.size();
	for(int i = 0; i < pastasSize; i++)
	{
		for (int j = 1; j < 11; j++)
		{
			string path = pathDiretory+"/sample/"+pastas[i]+"/" + to_string(j) + ".bmp";
			Mat img_gray = imread(path);
			cvtColor(img_gray, img_gray, COLOR_BGR2GRAY);
			img.push_back(img_gray);
			labels.push_back(i);
		}
	}
	Ptr<FaceRecognizer> model = createFisherFaceRecognizer();
	model->train(img, labels);
	model->save(pathDiretory+"/model.xml");
	putText(mat, "Treinamento Concluido", Point(100, 100), FONT_HERSHEY_SIMPLEX, 1, Scalar(0, 0, 255),4,8);
}

void fun(Mat& mat, CascadeClassifier& face_cascade, Ptr<FaceRecognizer> model)
{
	vector<Rect> faces;
	int faceSize = 0;
	Mat frame;
	Mat predect;
	cvtColor(mat, frame, COLOR_BGR2GRAY);
	face_cascade.detectMultiScale(frame, faces, 1.2, 7, 0, Size(80, 80));
	faceSize = faces.size();
	for (int i = 0; i < faceSize; i++)
	{
		frame(faces[i]).copyTo(predect);
		resize(predect,predect,Size(92,112));
		int label=-1;
		double predectnumber=0;
		model->predict(predect,label, predectnumber);
		rectangle(mat, Point(faces[i].x, faces[i].y), Point(faces[i].x + faces[i].width, faces[i].y + faces[i].height),
		Scalar(0, 255, 0), 1, 8);
		if (predectnumber>70)
			putText(mat, pastas[label], Point(faces[i].x, faces[i].y), FONT_HERSHEY_SIMPLEX, 1, Scalar(0, 0, 255), 4, 8);
		else
			putText(mat, "Desconhecido", Point(faces[i].x, faces[i].y), FONT_HERSHEY_SIMPLEX, 1, Scalar(0, 255, 255),4,8);
		
	}
}

void FaceRecognitionOpenCVImpl::process (cv::Mat &mat)
{
	pathDiretory = path;
  	switch(opFilter){
		case 0:	
			if(boolInit){
				makepicture(mat, newPerson);
				if(pic_num > 10){
					boolInit = 0;
					pic_num = 1;
				}
			}
			break;
		case 1:
			if(boolInit){
				boolInit = 0;
				initdata(mat);
			}
			break;
		case 2:
			if(boolInit){
				loadDir();
				modelXml = createFisherFaceRecognizer();
				modelXml->load(pathDiretory+"/model.xml");
				face_cascade.load(pathDiretory+"/haarcascade_frontalface_alt.xml");
				boolInit = 0;
			}
		  	fun(mat, face_cascade,modelXml);
			break;
		default:
			boolInit = 1;
	}

}

void FaceRecognitionOpenCVImpl::setConfig(const std::string &path, const int opFilter, const std::string &newPerson)
{
    this->path= path;
    this->opFilter= opFilter;
    this->newPerson= newPerson;
}



} /* facerecognition */
} /* module */
} /* kurento */
